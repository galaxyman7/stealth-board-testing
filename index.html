<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Stealth Board</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    /* ===== Basic layout and visuals ===== */
    body {
      background: #f9f9f9;
      font-family: sans-serif;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h2 { text-align: center; }
    svg {
      display: block;
      margin: 0 auto 20px auto;
      background: #eef;
    }
    text {
      font-size: 12px;
      fill: gray;
      text-anchor: start;
      dominant-baseline: hanging;
      pointer-events: none;
    }
    line { cursor: pointer; }

    #sessionControls { text-align: center; margin-bottom: 20px; }
    #sessionCodeInput { padding: 5px; }

    #searchToggle {
      display: block;
      margin: 10px auto 20px auto;
      padding: 8px 16px;
      font-size: 14px;
      background: #555;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #searchToggle.active { background: #2a8; }

    #printBtn, #saveBtn, #loadBtn {
      display: block;
      margin: 10px auto;
      padding: 10px 20px;
      font-size: 16px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    /* ===== Floating message styling ===== */
    #message {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 30px;
      border-radius: 8px;
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      opacity: 0;
      pointer-events: none;
    }
    #message.show { animation: slideFade 2s ease forwards; }
    #message.found { background: rgba(0, 128, 0, 0.85); }
    #message.nothing { background: rgba(200, 0, 0, 0.85); }
    #message.collision { background: rgba(255, 140, 0, 0.85); }

    @keyframes slideFade {
      0%   { opacity: 0; transform: translate(-50%, 0); }
      10%  { opacity: 1; transform: translate(-50%, 10px); }
      80%  { opacity: 1; transform: translate(-50%, 20px); }
      100% { opacity: 0; transform: translate(-50%, 40px); }
    }
  </style>
</head>
<body>

<h2>Stealth Board</h2>
<div id="sessionControls">
  <button id="createSessionBtn">Create Session (DM)</button>
  <input id="sessionCodeInput" placeholder="Enter Session Code">
  <button id="joinSessionBtn">Join Session (Player)</button>
  <p id="sessionInfo"></p>
</div>

<button id="searchToggle">Placement Mode</button>
<svg id="hexMap"></svg>

<!-- Host-only buttons (shown only if DM) -->
<button id="saveBtn" style="display:none;">Save Game</button>
<button id="loadBtn" style="display:none;">Load Game</button>

<button id="printBtn">Print / Export PDF</button>

<div id="message"></div>

<script>
/* ===== Global state variables ===== */
let peer = null;
let connections = [];        // Active PeerJS connections
let edgesMap = {};           // SVG line elements for barriers
let edgeStates = {};         // Which barriers are active
let hostCircleStates = {};   // Circles placed by DM (hidden from players)
let playerCircleStates = {}; // Circles placed by players (shared among players, hidden from DM)
let peerReady = false;
let searchMode = false;
let isHost = false;          // Determines DM vs player logic

/* ===== Generate short session code ===== */
function generateShortCode() {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for (let i = 0; i < 4; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

/* ===== Initialize PeerJS ===== */
function initPeer() {
  const code = generateShortCode();
  peer = new Peer(code);
  peer.on('open', (id) => {
    peerReady = true;
    console.log("PeerJS ready with ID:", id);
  });

  /* Handle incoming connections (only relevant if host) */
  peer.on('connection', (conn) => {
    connections.push(conn);
    conn.on('data', handleIncomingData);

    // Send full current state to ANY new/rejoining player
    conn.send({
      type: "syncAll",
      edges: edgeStates,
      hostCircles: hostCircleStates,
      playerCircles: playerCircleStates
    });
  });
}

initPeer();

/* ===== Broadcast helper ===== */
function broadcast(data) {
  connections.forEach(conn => conn.send(data));
}

/* ===== Handle incoming messages ===== */
function handleIncomingData(data) {
  if (data.type === "syncAll") {
    // Full sync (applies to both host and players when joining)
    edgeStates = data.edges;
    hostCircleStates = data.hostCircles;
    playerCircleStates = data.playerCircles;
    updateEdgesUI();
    updateCirclesUI();
  }

  if (data.type === "toggleEdge") {
    edgeStates[data.edgeId] = data.highlighted;
    updateEdgesUI();
  }

  if (data.type === "toggleCircle") {
    // Only players broadcast circle changes to each other
    playerCircleStates[data.circleId] = data.highlighted;
    updateCirclesUI();
  }
}

/* ===== UI update helpers ===== */
function updateEdgesUI() {
  for (const edgeId in edgesMap) {
    edgesMap[edgeId].setAttribute("stroke-width", edgeStates[edgeId] ? "6" : "2");
  }
}

function updateCirclesUI() {
  // Players see ONLY playerCircleStates (shared team info)
  // DM sees ONLY hostCircleStates (hidden from players)
  document.querySelectorAll("circle").forEach(circleEl => {
    const id = circleEl.id;
    if (isHost) {
      const highlight = hostCircleStates[id] || false;
      circleEl.setAttribute("stroke", highlight ? "black" : "transparent");
    } else {
      const highlight = playerCircleStates[id] || false;
      circleEl.setAttribute("stroke", highlight ? "black" : "transparent");
    }
  });
}

/* ===== Floating message utility ===== */
function showMessage(text, type) {
  const messageDiv = document.getElementById('message');
  messageDiv.textContent = text;
  messageDiv.className = ''; // reset
  messageDiv.classList.add('show', type);
  setTimeout(() => messageDiv.classList.remove('show', type), 2000);
}

/* ===== Session controls ===== */
document.getElementById('createSessionBtn').addEventListener('click', () => {
  if (!peerReady) return alert("Peer not ready yet. Please wait a second.");
  isHost = true;
  document.getElementById('sessionInfo').textContent = `Your Session Code: ${peer.id}`;
  document.getElementById('saveBtn').style.display = 'block';
  document.getElementById('loadBtn').style.display = 'block';
});

document.getElementById('joinSessionBtn').addEventListener('click', () => {
  const code = document.getElementById('sessionCodeInput').value.trim();
  if (!code) return alert("Enter a session code!");
  if (!peerReady) return alert("Peer not ready yet. Please wait a second.");

  const conn = peer.connect(code);
  conn.on('open', () => {
    connections.push(conn);
    document.getElementById('sessionInfo').textContent = `Connected to session: ${code}`;
  });
  conn.on('data', handleIncomingData);
});

/* ===== Grid / Hex generation ===== */
const svg = document.getElementById('hexMap');
const size = 60; // hex radius
const marginInches = 0.5;
const pageWidthIn = 8.5;
const pageHeightIn = 11;
const dpi = 96;

const marginPx = marginInches * dpi;
const pageWidthPx = pageWidthIn * dpi;
const pageHeightPx = pageHeightIn * dpi;

const drawWidth = pageWidthPx - 2 * marginPx;
const drawHeight = pageHeightPx - 2 * marginPx;

const hexWidth = Math.sqrt(3) * size;
const hexHeight = 2 * size;
const horizDist = hexWidth;
const vertDist = 0.75 * hexHeight;

const cols = Math.floor(drawWidth / horizDist);
const rows = Math.floor(drawHeight / vertDist);

const svgWidth = cols * horizDist + hexWidth;
const svgHeight = rows * vertDist + hexHeight;
svg.setAttribute('width', svgWidth);
svg.setAttribute('height', svgHeight);

/* ===== Create individual hex tiles ===== */
function createHex(x, y, label) {
  const points = [];
  for (let i = 0; i < 6; i++) {
    const angle = Math.PI / 3 * i - Math.PI / 6;
    const px = x + size * Math.cos(angle);
    const py = y + size * Math.sin(angle);
    points.push({ x: px, y: py });
  }

  // Draw edges (barriers)
  for (let i = 0; i < 6; i++) {
    const start = points[i];
    const end = points[(i + 1) % 6];

    const edge = document.createElementNS("http://www.w3.org/2000/svg", "line");
    edge.setAttribute("x1", start.x);
    edge.setAttribute("y1", start.y);
    edge.setAttribute("x2", end.x);
    edge.setAttribute("y2", end.y);
    edge.setAttribute("stroke", "#333");
    edge.setAttribute("stroke-width", "2");

    const edgeId = `${label}-edge-${i}`;
    edgesMap[edgeId] = edge;
    edgeStates[edgeId] = false;
    svg.appendChild(edge);

    // Invisible hitbox for easier clicking
    const hitbox = document.createElementNS("http://www.w3.org/2000/svg", "line");
    hitbox.setAttribute("x1", start.x);
    hitbox.setAttribute("y1", start.y);
    hitbox.setAttribute("x2", end.x);
    hitbox.setAttribute("y2", end.y);
    hitbox.setAttribute("stroke", "transparent");
    hitbox.setAttribute("stroke-width", "15");
    hitbox.style.cursor = "pointer";

    hitbox.addEventListener('click', () => {
      const newHighlighted = !(edgeStates[edgeId]);
      edgeStates[edgeId] = newHighlighted;
      updateEdgesUI();
      broadcast({ type: "toggleEdge", edgeId, highlighted: newHighlighted });
    });

    svg.appendChild(hitbox);
  }

  // Add label
  const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
  text.setAttribute("x", x - size * 0.4);
  text.setAttribute("y", y - size * 0.4);
  text.textContent = label;
  svg.appendChild(text);

  // Add 5 small circles (3 blue, 1 green, 1 red)
  const colors = ['#add8e6', '#add8e6', '#add8e6', '#90ee90', '#f08080'];
  const angleOffset = -Math.PI/2 + (72 * Math.PI/180); // rotated pentagon
  const radius = 25;

  colors.forEach((color, index) => {
    const angle = angleOffset + (index * 2 * Math.PI / 5);
    const cx = x + radius * Math.cos(angle);
    const cy = y + radius * Math.sin(angle);

    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", cx);
    circle.setAttribute("cy", cy);
    circle.setAttribute("r", 6);
    circle.setAttribute("fill", color);
    circle.setAttribute("stroke", "transparent");
    circle.setAttribute("stroke-width", "3");
    circle.setAttribute("id", `${label}-circle-${index}`);

    const circleId = `${label}-circle-${index}`;
    hostCircleStates[circleId] = false;
    playerCircleStates[circleId] = false;

    circle.addEventListener('click', () => {
      if (searchMode) {
        // In search mode, check opposing team's circles
        if (isHost) {
          // Host searches for player pieces
          if (playerCircleStates[circleId]) {
            showMessage("Found!", "found");
          } else {
            showMessage("Nothing Found", "nothing");
          }
        } else {
          // Players search for host pieces
          if (hostCircleStates[circleId]) {
            showMessage("Found!", "found");
          } else {
            showMessage("Nothing Found", "nothing");
          }
        }
      } else {
        // Placement mode: toggle own team's circles
        if (isHost) {
          hostCircleStates[circleId] = !hostCircleStates[circleId];
        } else {
          playerCircleStates[circleId] = !playerCircleStates[circleId];
          broadcast({ type: "toggleCircle", circleId, highlighted: playerCircleStates[circleId] });
        }

        // Update local visuals
        updateCirclesUI();

        // Check for collision (both teams placed here)
        if (hostCircleStates[circleId] && playerCircleStates[circleId]) {
          showMessage("Collision!", "collision");
          // Highlight red to indicate collision
          const circleEl = document.getElementById(circleId);
          circleEl.setAttribute("stroke", "red");
        }
      }
    });

    svg.appendChild(circle);
  });
}

/* ===== Build the entire hex grid ===== */
for (let row = 0; row < rows; row++) {
  const rowLetter = String.fromCharCode(65 + (row % 26));
  for (let col = 0; col < cols; col++) {
    const xOffset = (row % 2 === 0) ? 0 : horizDist / 2;
    const x = col * horizDist + xOffset + size;
    const y = row * vertDist + size;
    const label = `${rowLetter}${col + 1}`;
    createHex(x, y, label);
  }
}

/* ===== Toggle search vs placement mode ===== */
const searchToggle = document.getElementById('searchToggle');
searchToggle.addEventListener('click', () => {
  searchMode = !searchMode;
  searchToggle.classList.toggle('active', searchMode);
  searchToggle.textContent = searchMode ? "Search Mode" : "Placement Mode";
});

/* ===== Save / Load (host only) ===== */
document.getElementById('saveBtn').addEventListener('click', () => {
  if (!isHost) return;
  const data = JSON.stringify({
    edges: edgeStates,
    hostCircles: hostCircleStates,
    playerCircles: playerCircleStates
  });
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'stealth-save.json';
  a.click();
  URL.revokeObjectURL(url);
});

document.getElementById('loadBtn').addEventListener('click', () => {
  if (!isHost) return;
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'application/json';
  input.onchange = e => {
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = () => {
      const data = JSON.parse(reader.result);
      edgeStates = data.edges;
      hostCircleStates = data.hostCircles;
      playerCircleStates = data.playerCircles;
      updateEdgesUI();
      updateCirclesUI();
      broadcast({
        type: "syncAll",
        edges: edgeStates,
        hostCircles: hostCircleStates,
        playerCircles: playerCircleStates
      });
    };
    reader.readAsText(file);
  };
  input.click();
});

/* ===== PDF Export ===== */
document.getElementById('printBtn').addEventListener('click', () => {
  const { jsPDF } = window.jspdf;
  const svgData = new XMLSerializer().serializeToString(svg);
  const svgBlob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
  const url = URL.createObjectURL(svgBlob);
  const img = new Image();
  img.onload = function() {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = svg.clientWidth;
    canvas.height = svg.clientHeight;
    ctx.drawImage(img, 0, 0);
    const imgData = canvas.toDataURL("image/png");
    const pdf = new jsPDF({ orientation: 'portrait', unit: 'in', format: 'letter' });
    const pageWidth = 8.5;
    const pageHeight = 11;
    const margin = 0.5;
    const usableWidth = pageWidth - 2 * margin;
    const usableHeight = pageHeight - 2 * margin;
    const imgWidth = canvas.width / dpi;
    const imgHeight = canvas.height / dpi;
    let scale = Math.min(usableWidth / imgWidth, usableHeight /
